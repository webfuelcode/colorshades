<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Color Combination Maker â€” Grid (Card style)</title>

  <!-- Bootstrap (you already use) -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

  <!-- Your global theme (keep this) -->
  <link href="main-theme.css" rel="stylesheet">

  <style>
    /* Minimal page-level helpers â€” won't override your theme colors */
    .color-tool { max-width: 1200px; margin: 32px auto; padding: 18px; }
    .controls { display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-bottom:18px; }
    .controls .hex-input { width:140px; }
    .swatch-grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap:16px; }

    /* Card-style swatch */
    .swatch-card {
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 8px 22px rgba(0,0,0,0.25);
      transition: transform .18s ease, box-shadow .18s ease;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.04));
      border: 1px solid rgba(255,255,255,0.03);
    }
    .swatch-card:hover { transform: translateY(-6px); box-shadow: 0 14px 34px rgba(0,0,0,0.32); }

    .swatch-color {
      height: 110px;
      width: 100%;
      display:block;
    }
    .swatch-body {
      padding:10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .swatch-hex {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      font-weight:700;
      font-size:0.92rem;
    }

    /* small safe container for the copy button to allow absolute badge from global CSS */
    .copy-container { position: relative; display:inline-block; }

    /* Responsive tweaks */
    @media (max-width:640px) {
      .swatch-color { height: 90px; }
    }
  </style>
</head>
<body class="dark-theme">
  <div class="container color-tool">
    <div class="card tool p-4">
      <div class="d-flex justify-content-between align-items-center mb-3 flex-wrap">
        <h4 class="mb-2">ðŸŽ¨ Color Combination Maker (Grid)</h4>
        <div class="small text-white-50 mb-2">Create 18â€“22 matching colors from any base HEX</div>
      </div>

      <div class="controls">
        <label class="d-flex align-items-center gap-2 mb-0">
          <span class="small-muted">Base color</span>
          <input id="colorPicker" type="color" value="#3498db" class="form-control form-control-color" title="Choose base color">
        </label>

        <label class="d-flex align-items-center gap-2 mb-0">
          <span class="small-muted">HEX</span>
          <input id="hexInput" class="form-control hex-input" type="text" maxlength="7" value="#3498db" placeholder="#RRGGBB">
        </label>

        <button id="generateBtn" class="btn btn-primary">Generate Combinations</button>
        <button id="randomBtn" class="btn btn-outline-light">Random Base</button>

        <div class="ms-auto text-end small-muted">
          <div>Click any card or the Copy button to copy HEX</div>
        </div>
      </div>

      <div id="swatchGrid" class="swatch-grid"></div>
    </div>
  </div>

  <!-- fallback copy/animate script (only triggers if global copy handler not present).
       If you already added the universal copy script that listens for data-copy-target, this will not interfere. -->
  <script>
  (function () {
    // color helpers
    function clamp(v, a, b) { return Math.min(b, Math.max(a, v)); }
    function hexToRgb(hex) {
      hex = (hex || '').replace('#','').trim();
      if (hex.length === 3) hex = hex.split('').map(h=>h+h).join('');
      if (!/^[0-9A-Fa-f]{6}$/.test(hex)) return null;
      const n = parseInt(hex, 16);
      return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
    }
    function rgbToHex(r,g,b){
      const toHex = v => v.toString(16).padStart(2,'0').toUpperCase();
      return '#' + toHex(r) + toHex(g) + toHex(b);
    }
    function rgbToHsl(r,g,b){
      r/=255; g/=255; b/=255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b);
      let h=0, s=0, l=(max+min)/2;
      if(max!==min){
        const d = max-min;
        s = l > 0.5 ? d/(2-max-min) : d/(max+min);
        switch(max){
          case r: h = (g-b)/d + (g < b ? 6 : 0); break;
          case g: h = (b-r)/d + 2; break;
          case b: h = (r-g)/d + 4; break;
        }
        h /= 6;
      }
      return { h: Math.round(h*360), s: Math.round(s*100), l: Math.round(l*100) };
    }
    function hslToRgb(h,s,l){
      h = ((h % 360) + 360) % 360;
      s /= 100; l /= 100;
      if (s === 0) {
        const v = Math.round(l*255);
        return { r:v,g:v,b:v };
      }
      const q = l < 0.5 ? l*(1+s) : l + s - l*s;
      const p = 2*l - q;
      const hk = h/360;
      function calc(t){
        if(t<0) t+=1; if(t>1) t-=1;
        if(t < 1/6) return p + (q-p)*6*t;
        if(t < 1/2) return q;
        if(t < 2/3) return p + (q-p)*(2/3 - t)*6;
        return p;
      }
      const r = Math.round(calc(hk+1/3)*255);
      const g = Math.round(calc(hk)*255);
      const b = Math.round(calc(hk-1/3)*255);
      return { r,g,b };
    }

    // generate variants: harmonies + tints/shades + desaturated + mixes
    function buildPalette(hexBase){
      const rgb = hexToRgb(hexBase);
      if (!rgb) return [];
      const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);

      const out = [];
      // include base
      out.push({ label: 'Base', hex: hexBase.toUpperCase() });

      // complementary
      out.push({ label: 'Complement', hex: hslToHex((hsl.h + 180), hsl.s, hsl.l) });

      // analogous +/- 30, +/- 60
      out.push({ label: 'Analogous -60', hex: hslToHex(hsl.h - 60, hsl.s, hsl.l) });
      out.push({ label: 'Analogous -30', hex: hslToHex(hsl.h - 30, hsl.s, hsl.l) });
      out.push({ label: 'Analogous +30', hex: hslToHex(hsl.h + 30, hsl.s, hsl.l) });
      out.push({ label: 'Analogous +60', hex: hslToHex(hsl.h + 60, hsl.s, hsl.l) });

      // triadic
      out.push({ label: 'Triadic -120', hex: hslToHex(hsl.h - 120, hsl.s, hsl.l) });
      out.push({ label: 'Triadic +120', hex: hslToHex(hsl.h + 120, hsl.s, hsl.l) });

      // tetradic / double complementary
      out.push({ label: 'Tetradic +90', hex: hslToHex(hsl.h + 90, hsl.s, hsl.l) });
      out.push({ label: 'Tetradic -90', hex: hslToHex(hsl.h - 90, hsl.s, hsl.l) });

      // shades & tints (darker / lighter steps)
      const shadeSteps = [-30, -15, 15, 30];
      shadeSteps.forEach((step,i) => {
        out.push({ label: 'Shade/Tint ' + (i+1), hex: hslToHex(hsl.h, hsl.s, clamp(hsl.l + step, 6, 94)) });
      });

      // desaturated / pastel versions
      out.push({ label: 'Desaturate -30', hex: hslToHex(hsl.h, clamp(hsl.s - 30, 0, 100), clamp(hsl.l + 8, 6, 94)) });
      out.push({ label: 'Soft +20', hex: hslToHex(hsl.h, clamp(hsl.s - 10, 0, 100), clamp(hsl.l + 20, 6, 94)) });

      // mixes with black & white
      out.push({ label: 'Mix White 30%', hex: mixHex(hexBase, '#ffffff', 0.3) });
      out.push({ label: 'Mix Black 30%', hex: mixHex(hexBase, '#000000', 0.3) });

      // a couple of random tints around base
      for (let i=0; i<3; i++){
        out.push({ label: 'Variant ' + (i+1), hex: hslToHex(hsl.h + (i+1)*7, clamp(hsl.s - (i*4),0,100), clamp(hsl.l + (i*5),6,94)) });
      }

      // collapse duplicates & uppercase
      const seen = new Set();
      const uniq = [];
      for (const c of out) {
        const h = (c.hex || '').toUpperCase();
        if (!h || seen.has(h)) continue;
        seen.add(h);
        uniq.push({ label: c.label, hex: h });
      }
      // ensure large palette: if too few, create light/dark tints
      if (uniq.length < 18) {
        const add = [];
        for (let i=0;i<20-uniq.length;i++){
          const idx = i % uniq.length;
          const hsl2 = rgbToHsl(...Object.values(hexToRgb(uniq[idx].hex)));
          const hex = hslToHex(hsl2.h, clamp(hsl2.s - (i*3),0,100), clamp(hsl2.l + ((i%2?1:-1)*(8 + i)),6,94));
          add.push({ label:'Extra ' + (i+1), hex });
        }
        uniq.push(...add);
      }
      // trim to 20
      return uniq.slice(0, 20);
    }

    // helpers: mix and hsl->hex
    function mixHex(a,b,ratio){
      const A = hexToRgb(a), B = hexToRgb(b);
      if (!A || !B) return a.toUpperCase();
      const r = Math.round(A.r*(1-ratio) + B.r*ratio);
      const g = Math.round(A.g*(1-ratio) + B.g*ratio);
      const bl = Math.round(A.b*(1-ratio) + B.b*ratio);
      return rgbToHex(r,g,bl);
    }
    function hslToHex(h,s,l){
      const rgb = hslToRgb(Math.round(h), Math.round(s), Math.round(l));
      return rgbToHex(rgb.r, rgb.g, rgb.b);
    }

    // render grid
    const grid = document.getElementById('swatchGrid');
    function renderGrid(baseHex) {
      const palette = buildPalette(baseHex);
      grid.innerHTML = '';
      palette.forEach((p, idx) => {
        const idHex = 'hex_' + idx;
        const card = document.createElement('div');
        card.className = 'swatch-card';
        card.innerHTML = `
          <div class="swatch-color" style="background:${p.hex}" title="${p.label}"></div>
          <div class="swatch-body">
            <div>
              <div class="text-muted small">${escapeHtml(p.label)}</div>
              <div id="${idHex}" class="swatch-hex">${p.hex}</div>
            </div>
            <div class="copy-container">
              <button class="btn btn-sm btn-outline-light" data-copy-target="${idHex}" data-copy-text="Copied!">
                <i class="bi bi-clipboard"></i>
                <span class="ms-2 d-none d-md-inline">Copy</span>
              </button>
            </div>
          </div>
        `;
        // clicking entire card copies hex (same behavior)
        card.addEventListener('click', (e) => {
          // avoid double-firing when clicking copy button (it will be handled by copy handler)
          const btn = card.querySelector('[data-copy-target]');
          if (e.target === btn || btn.contains(e.target)) return;
          triggerCopy(idHex, card.querySelector('button'));
        });
        grid.appendChild(card);
      });
    }

    // sync color picker + hex input
    const colorPicker = document.getElementById('colorPicker');
    const hexInput = document.getElementById('hexInput');
    colorPicker.addEventListener('input', ()=> { hexInput.value = colorPicker.value.toUpperCase(); });
    hexInput.addEventListener('input', ()=> {
      const val = hexInput.value.trim();
      if (/^#?[0-9A-Fa-f]{3,6}$/.test(val)) {
        const withHash = val.startsWith('#') ? val : '#'+val;
        colorPicker.value = expandShortHex(withHash).toUpperCase();
      }
    });

    document.getElementById('generateBtn').addEventListener('click', ()=>{
      const hex = hexInput.value.trim();
      const valid = /^#?[0-9A-Fa-f]{3,6}$/.test(hex);
      if (!valid) { alert('Enter a valid HEX like #3498db'); return; }
      renderGrid(expandShortHex(hex));
    });

    document.getElementById('randomBtn').addEventListener('click', ()=>{
      const random = '#'+Math.floor(Math.random()*0xFFFFFF).toString(16).padStart(6,'0');
      colorPicker.value = random;
      hexInput.value = random.toUpperCase();
      renderGrid(random);
    });

    // helper: ensure 6-digit hex with #
    function expandShortHex(h) {
      if (!h) return '#000000';
      let s = h.replace('#','');
      if (s.length === 3) s = s.split('').map(ch => ch+ch).join('');
      return '#'+s.toUpperCase();
    }

    // fallback copy if no global data-copy-target handler registered: use event delegation
    function triggerCopy(targetId, buttonEl){
      // if global initCopyButtons exists it will handle button clicks; call it to ensure bindings
      if (window.initCopyButtons) {
        // ensure button is initialized
        window.initCopyButtons();
        // simulate click on button
        buttonEl && buttonEl.click();
        return;
      }
      // fallback: copy directly and animate simple
      const el = document.getElementById(targetId);
      if (!el) return;
      const text = el.innerText || el.textContent || '';
      navigator.clipboard.writeText(text).then(()=> {
        // simple anim: add class then remove
        buttonEl && buttonEl.classList.add('copy-animate');
        // show temporary inline label
        const badge = document.createElement('span');
        badge.className = 'copy-badge show';
        badge.textContent = 'Copied!';
        const wrapper = buttonEl.closest('.copy-container') || buttonEl.parentElement;
        wrapper.appendChild(badge);
        setTimeout(()=> {
          buttonEl && buttonEl.classList.remove('copy-animate');
          badge.remove();
        }, 900);
      });
    }

    // small utility to escape labels
    function escapeHtml(s) {
      return (s+'').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[c]);
    }

    // initial render
    renderGrid(colorPicker.value);
  })();
  </script>
</body>
</html>
